#[tonic::async_trait]
impl DbmsService for MyService {
    type ClientServerStream = Pin<Box<dyn Stream<Item = Result<ResultMessage, Status>> + Send + Sync + 'static>>;

    async fn client_server(
        &self,
        request: Request<tonic::Streaming<ClientReq>>,
    ) -> Result<Response<Self::ClientServerStream>, Status> {
        println!("ClientServerMsg stream started");

        let mut stream = request.into_inner();
        let result_sender = self.result_sender.clone();

        // 创建一个新的 channel 供此连接发送响应
        let (response_tx, response_rx) = mpsc::channel(4);

        tokio::spawn(async move {
            while let Some(req) = stream.next().await {
                match req {
                    Ok(client_req) => {
                        println!("Received ClientReq: {:?}", client_req);

                        // 处理任务并将结果发送到共享的 result_sender
                        let result = process_task(client_req);
                        if result_sender.send(result).await.is_err() {
                            eprintln!("Failed to send result to gRPC service");
                            break;
                        }
                    }
                    Err(e) => {
                        eprintln!("Error receiving ClientReq: {:?}", e);
                        break;
                    }
                }
            }
        });

        // 将 response_rx 转换为 gRPC 响应流
        let response_stream = ReceiverStream::new(response_rx);

        Ok(Response::new(Box::pin(response_stream) as Self::ClientServerStream))
    }
}